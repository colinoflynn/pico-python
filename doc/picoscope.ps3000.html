<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Python: module picoscope.ps3000</title>
</head><body>

<table class="heading">
<tr class="heading-text decor">
<td class="title">&nbsp;<br><strong class="title"><a href="picoscope.html" class="white">picoscope</a>.ps3000</strong></td>
<td class="extra"><a href=".">index</a><br><a href="file:c%3A%5Cusers%5Cjoseph%5Cnextcloud%5Cmeine%20daten%5Cdocuments%5Cprogrammieren%5Cpico-python%5Cpicoscope%5Cps3000.py">c:\users\joseph\nextcloud\meine daten\documents\programmieren\pico-python\picoscope\ps3000.py</a></td></tr></table>
    <p><span class="code">This&nbsp;is&nbsp;the&nbsp;low&nbsp;level&nbsp;driver&nbsp;file&nbsp;for&nbsp;a&nbsp;specific&nbsp;Picoscope.<br>
&nbsp;<br>
By&nbsp;this,&nbsp;I&nbsp;mean&nbsp;if&nbsp;parameters&nbsp;want&nbsp;to&nbsp;get&nbsp;passed&nbsp;as&nbsp;strings,&nbsp;they&nbsp;should&nbsp;be<br>
handled&nbsp;by&nbsp;PSBase<br>
All&nbsp;functions&nbsp;here&nbsp;should&nbsp;take&nbsp;things&nbsp;as&nbsp;close&nbsp;to&nbsp;integers&nbsp;as&nbsp;possible,&nbsp;the<br>
only&nbsp;exception&nbsp;here&nbsp;is&nbsp;for&nbsp;array&nbsp;parameters.&nbsp;Array&nbsp;parameters&nbsp;should&nbsp;be&nbsp;passed<br>
in&nbsp;a&nbsp;pythonic&nbsp;way&nbsp;through&nbsp;numpy&nbsp;since&nbsp;the&nbsp;PSBase&nbsp;class&nbsp;should&nbsp;not&nbsp;be&nbsp;aware&nbsp;of<br>
the&nbsp;specifics&nbsp;behind&nbsp;how&nbsp;the&nbsp;clib&nbsp;is&nbsp;called.<br>
&nbsp;<br>
The&nbsp;functions&nbsp;should&nbsp;not&nbsp;have&nbsp;any&nbsp;default&nbsp;values&nbsp;as&nbsp;these&nbsp;should&nbsp;be&nbsp;handled<br>
by&nbsp;PSBase.</span></p>
<p>
<table class="section">
<tr class="decor pkg-content-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><strong class="bigsection">Modules</strong></td></tr>
    
<tr><td class="decor pkg-content-decor"><span class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td><td>&nbsp;</td>
<td class="singlecolumn"><table><tr><td class="multicolumn"><a href="inspect.html">inspect</a><br>
</td><td class="multicolumn"></td><td class="multicolumn"></td><td class="multicolumn"></td></tr></table></td></tr></table><p>
<table class="section">
<tr class="decor index-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><strong class="bigsection">Classes</strong></td></tr>
    
<tr><td class="decor index-decor"><span class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td><td>&nbsp;</td>
<td class="singlecolumn"><dl>
<dt class="heading-text"><a href="picoscope.picobase.html#_PicoscopeBase">picoscope.picobase._PicoscopeBase</a>(<a href="builtins.html#object">builtins.object</a>)
</dt><dd>
<dl>
<dt class="heading-text"><a href="picoscope.ps3000.html#PS3000">PS3000</a>
</dt></dl>
</dd>
</dl>
 <p>
<table class="section">
<tr class="decor title-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><a name="PS3000">class <strong>PS3000</strong></a>(<a href="picoscope.picobase.html#_PicoscopeBase">picoscope.picobase._PicoscopeBase</a>)</td></tr>
    
<tr><td class="decor title-decor" rowspan=2><span class="code">&nbsp;&nbsp;&nbsp;</span></td>
<td class="decor title-decor" colspan=2><span class="code"><a href="#PS3000">PS3000</a>(serialNumber=None,&nbsp;connect=True,&nbsp;dllPath=None)<br>
&nbsp;<br>
The&nbsp;following&nbsp;are&nbsp;low-level&nbsp;functions&nbsp;for&nbsp;the&nbsp;<a href="#PS3000">PS3000</a>.<br>&nbsp;</span></td></tr>
<tr><td>&nbsp;</td>
<td class="singlecolumn"><dl><dt>Method resolution order:</dt>
<dd><a href="picoscope.ps3000.html#PS3000">PS3000</a></dd>
<dd><a href="picoscope.picobase.html#_PicoscopeBase">picoscope.picobase._PicoscopeBase</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="PS3000-__init__"><strong>__init__</strong></a>(self, serialNumber=None, connect=True, dllPath=None)</dt><dd><span class="code">Load&nbsp;DLL&nbsp;and&nbsp;setup&nbsp;API.<br>
&nbsp;<br>
:param&nbsp;serialNumber:&nbsp;The&nbsp;serial&nbsp;number&nbsp;of&nbsp;the&nbsp;device&nbsp;to&nbsp;connect&nbsp;to.<br>
:param&nbsp;connect:&nbsp;If&nbsp;True,&nbsp;then&nbsp;connect&nbsp;to&nbsp;the&nbsp;device.<br>
:param&nbsp;dllPath:&nbsp;The&nbsp;path&nbsp;to&nbsp;the&nbsp;dll&nbsp;if&nbsp;not&nbsp;in&nbsp;standard&nbsp;location.</span></dd></dl>

<dl><dt><a name="PS3000-checkResult"><strong>checkResult</strong></a>(self, ec)</dt><dd><span class="code">Check&nbsp;result&nbsp;of&nbsp;function&nbsp;calls,&nbsp;raise&nbsp;exception&nbsp;if&nbsp;not&nbsp;0.</span></dd></dl>

<dl><dt><a name="PS3000-getTimeBaseNum"><strong>getTimeBaseNum</strong></a>(self, sampleTimeS)</dt><dd><span class="code">ps3000&nbsp;doesn't&nbsp;seem&nbsp;to&nbsp;have&nbsp;published&nbsp;formula&nbsp;like&nbsp;other&nbsp;scopes.</span></dd></dl>

<dl><dt><a name="PS3000-getTimestepFromTimebase"><strong>getTimestepFromTimebase</strong></a>(self, timebase)</dt><dd><span class="code">Return&nbsp;timestep&nbsp;from&nbsp;Timebase.</span></dd></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>CHANNELS</strong> = {'A': 0, 'B': 1, 'MaxChannels': 2}</dl>

<dl><dt><strong>CHANNEL_COUPLINGS</strong> = {'AC': 0, 'DC': 1}</dl>

<dl><dt><strong>CHANNEL_RANGE</strong> = [{'apivalue': 1, 'rangeStr': '20 mV', 'rangeV': 0.02}, {'apivalue': 2, 'rangeStr': '50 mV', 'rangeV': 0.05}, {'apivalue': 3, 'rangeStr': '100 mV', 'rangeV': 0.1}, {'apivalue': 4, 'rangeStr': '200 mV', 'rangeV': 0.2}, {'apivalue': 5, 'rangeStr': '500 mV', 'rangeV': 0.5}, {'apivalue': 6, 'rangeStr': '1 V', 'rangeV': 1.0}, {'apivalue': 7, 'rangeStr': '2 V', 'rangeV': 2.0}, {'apivalue': 8, 'rangeStr': '5 V', 'rangeV': 5.0}, {'apivalue': 9, 'rangeStr': '10 V', 'rangeV': 10.0}, {'apivalue': 10, 'rangeStr': '20 V', 'rangeV': 20.0}]</dl>

<dl><dt><strong>LIBNAME</strong> = 'ps3000'</dl>

<dl><dt><strong>MAX_TIMEBASES</strong> = 19</dl>

<dl><dt><strong>MAX_VALUE</strong> = 32767</dl>

<dl><dt><strong>MIN_VALUE</strong> = -32767</dl>

<dl><dt><strong>NUM_CHANNELS</strong> = 2</dl>

<dl><dt><strong>SWEEP_TYPES</strong> = {'Down': 1, 'DownUp': 3, 'Up': 0, 'UpDown': 2}</dl>

<dl><dt><strong>THRESHOLD_TYPE</strong> = {'Falling': 1, 'Rising': 0}</dl>

<dl><dt><strong>TIME_UNITS</strong> = {'FS': 0, 'MS': 4, 'NS': 2, 'PS': 1, 'S': 5, 'US': 3}</dl>

<dl><dt><strong>UNIT_INFO_TYPES</strong> = {'BatchAndSerial': 4, 'CalDate': 5, 'DriverVersion': 0, 'ErrorCode': 6, 'HardwareVersion': 2, 'KernelVersion': 7, 'USBVersion': 1, 'VariantInfo': 3}</dl>

<dl><dt><strong>WAVE_TYPES</strong> = {'DCVoltage': 5, 'RampDown': 4, 'RampUp': 3, 'Sine': 0, 'Square': 1, 'Triangle': 2}</dl>

<dl><dt><strong>channelBuffersLen</strong> = [0, 0]</dl>

<dl><dt><strong>channelBuffersPtr</strong> = [c_void_p(None), c_void_p(None)]</dl>

<hr>
Methods inherited from <a href="picoscope.picobase.html#_PicoscopeBase">picoscope.picobase._PicoscopeBase</a>:<br>
<dl><dt><a name="PS3000-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="PS3000-changePowerSource"><strong>changePowerSource</strong></a>(self, powerstate)</dt><dd><span class="code">Change&nbsp;the&nbsp;powerstate&nbsp;of&nbsp;the&nbsp;scope.<br>
&nbsp;<br>
Valid&nbsp;only&nbsp;for&nbsp;PS54XXA/B?</span></dd></dl>

<dl><dt><a name="PS3000-close"><strong>close</strong></a>(self)</dt><dd><span class="code">Close&nbsp;the&nbsp;scope.<br>
&nbsp;<br>
You&nbsp;should&nbsp;call&nbsp;this&nbsp;yourself&nbsp;because&nbsp;the&nbsp;Python&nbsp;garbage&nbsp;collector<br>
might&nbsp;take&nbsp;some&nbsp;time.</span></dd></dl>

<dl><dt><a name="PS3000-enumerateUnits"><strong>enumerateUnits</strong></a>(self)</dt><dd><span class="code">Return&nbsp;connected&nbsp;units&nbsp;as&nbsp;serial&nbsp;numbers&nbsp;as&nbsp;list&nbsp;of&nbsp;strings.</span></dd></dl>

<dl><dt><a name="PS3000-errorNumToDesc"><strong>errorNumToDesc</strong></a>(self, errorCode)</dt><dd><span class="code">Return&nbsp;the&nbsp;description&nbsp;of&nbsp;the&nbsp;`errorCode`&nbsp;as&nbsp;a&nbsp;string.</span></dd></dl>

<dl><dt><a name="PS3000-errorNumToName"><strong>errorNumToName</strong></a>(self, errorCode)</dt><dd><span class="code">Return&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;`errorCode`&nbsp;as&nbsp;a&nbsp;string.</span></dd></dl>

<dl><dt><a name="PS3000-flashLed"><strong>flashLed</strong></a>(self, times=5, start=False, stop=False)</dt><dd><span class="code">Flash&nbsp;the&nbsp;front&nbsp;panel&nbsp;LEDs.<br>
&nbsp;<br>
Parameters<br>
----------<br>
times&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;times&nbsp;to&nbsp;flash&nbsp;the&nbsp;LED<br>
start&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;the&nbsp;LED&nbsp;to&nbsp;flash&nbsp;indefinitely.&nbsp;Equals&nbsp;times&nbsp;&lt;&nbsp;0.<br>
stop&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;Stop&nbsp;the&nbsp;LED&nbsp;to&nbsp;flash.&nbsp;Equals&nbsp;times&nbsp;==&nbsp;0<br>
&nbsp;<br>
Note&nbsp;that&nbsp;calls&nbsp;to&nbsp;the&nbsp;RunStreaming&nbsp;or&nbsp;RunBlock&nbsp;will&nbsp;stop&nbsp;any&nbsp;flashing.</span></dd></dl>

<dl><dt><a name="PS3000-getAWGDeltaPhase"><strong>getAWGDeltaPhase</strong></a>(self, timeIncrement)</dt><dd><span class="code">Return&nbsp;the&nbsp;deltaPhase&nbsp;integer&nbsp;used&nbsp;by&nbsp;the&nbsp;AWG.<br>
&nbsp;<br>
This&nbsp;is&nbsp;useful&nbsp;when&nbsp;you&nbsp;are&nbsp;trying&nbsp;to&nbsp;generate&nbsp;very&nbsp;fast&nbsp;waveforms&nbsp;when<br>
you&nbsp;are&nbsp;getting&nbsp;close&nbsp;to&nbsp;the&nbsp;limits&nbsp;of&nbsp;your&nbsp;waveform&nbsp;generator.<br>
&nbsp;<br>
For&nbsp;example,&nbsp;the&nbsp;PS6000's&nbsp;DDS&nbsp;phase&nbsp;accumulator&nbsp;increments&nbsp;by<br>
deltaPhase&nbsp;every&nbsp;AWGDACInterval.<br>
The&nbsp;top&nbsp;2**self.<strong>AWGBufferAddressWidth</strong>&nbsp;bits&nbsp;indicate&nbsp;which&nbsp;sample&nbsp;is<br>
being&nbsp;output&nbsp;by&nbsp;the&nbsp;DDS.</span></dd></dl>

<dl><dt><a name="PS3000-getAWGTimeIncrement"><strong>getAWGTimeIncrement</strong></a>(self, deltaPhase)</dt><dd><span class="code">Return&nbsp;the&nbsp;time&nbsp;between&nbsp;AWG&nbsp;samples&nbsp;given&nbsp;a&nbsp;certain&nbsp;deltaPhase.<br>
&nbsp;<br>
You&nbsp;should&nbsp;use&nbsp;this&nbsp;function&nbsp;in&nbsp;conjunction&nbsp;with<br>
getAWGDeltaPhase&nbsp;to&nbsp;obtain&nbsp;the&nbsp;actual&nbsp;timestep&nbsp;of&nbsp;AWG.</span></dd></dl>

<dl><dt><a name="PS3000-getAllUnitInfo"><strong>getAllUnitInfo</strong></a>(self)</dt><dd><span class="code">Return&nbsp;a&nbsp;string&nbsp;containing&nbsp;all&nbsp;information&nbsp;of&nbsp;the&nbsp;device.</span></dd></dl>

<dl><dt><a name="PS3000-getDataRaw"><strong>getDataRaw</strong></a>(self, channel='A', numSamples=0, startIndex=0, downSampleRatio=1, downSampleMode=0, segmentIndex=0, data=None)</dt><dd><span class="code">Return&nbsp;the&nbsp;data&nbsp;of&nbsp;a&nbsp;single&nbsp;channel.<br>
&nbsp;<br>
Paramters<br>
---------<br>
channel<br>
&nbsp;&nbsp;&nbsp;&nbsp;Scope&nbsp;channel&nbsp;number&nbsp;or&nbsp;name.<br>
numSamples<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;samples&nbsp;to&nbsp;return.&nbsp;If&nbsp;0,&nbsp;take&nbsp;the&nbsp;calculated&nbsp;number&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;sampling&nbsp;interval/frequency.<br>
startIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;sample&nbsp;to&nbsp;start&nbsp;transfer.<br>
downSampleRatio<br>
&nbsp;&nbsp;&nbsp;&nbsp;Downsampling&nbsp;factor&nbsp;that&nbsp;will&nbsp;be&nbsp;applied&nbsp;to&nbsp;the&nbsp;raw&nbsp;data.&nbsp;Multiple<br>
&nbsp;&nbsp;&nbsp;&nbsp;downsampling&nbsp;modes&nbsp;can&nbsp;be&nbsp;bitwise-ORed&nbsp;together,&nbsp;but&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;downSampleRatio&nbsp;must&nbsp;be&nbsp;the&nbsp;same&nbsp;for&nbsp;all&nbsp;modes.<br>
downSampleMode<br>
&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;of&nbsp;downsampling.<br>
segmentIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;memory&nbsp;segment&nbsp;to&nbsp;get&nbsp;data&nbsp;from.<br>
data<br>
&nbsp;&nbsp;&nbsp;&nbsp;Numpy&nbsp;array&nbsp;to&nbsp;fill&nbsp;with&nbsp;the&nbsp;data.&nbsp;If&nbsp;None,&nbsp;create&nbsp;an&nbsp;empty&nbsp;one.<br>
&nbsp;<br>
Return<br>
------<br>
data&nbsp;:&nbsp;numpy&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;with&nbsp;the&nbsp;digitalized&nbsp;measurement&nbsp;values.<br>
NumSamplesReturned&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;samples&nbsp;returned.<br>
overflow&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;the&nbsp;measured&nbsp;value&nbsp;exceeded&nbsp;the&nbsp;measurement&nbsp;range.</span></dd></dl>

<dl><dt><a name="PS3000-getDataRawBulk"><strong>getDataRawBulk</strong></a>(self, channel='A', numSamples=0, fromSegment=0, toSegment=None, downSampleRatio=1, downSampleMode=0, data=None)</dt><dd><span class="code">Get&nbsp;one&nbsp;or&nbsp;more&nbsp;waveforms&nbsp;collected&nbsp;in&nbsp;rapid&nbsp;block&nbsp;mode.<br>
&nbsp;<br>
Parameters<br>
----------<br>
channel<br>
&nbsp;&nbsp;&nbsp;&nbsp;Scope&nbsp;channel&nbsp;number&nbsp;or&nbsp;name.<br>
numSamples<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;samples&nbsp;per&nbsp;segment&nbsp;to&nbsp;return.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;0,&nbsp;take&nbsp;the&nbsp;calculated&nbsp;number&nbsp;from&nbsp;set&nbsp;sampling&nbsp;interval.<br>
fromSegment<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;first&nbsp;segment&nbsp;to&nbsp;retrieve&nbsp;data&nbsp;from.<br>
toSegment<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;last&nbsp;segment&nbsp;to&nbsp;retrieve&nbsp;data&nbsp;from.&nbsp;If&nbsp;None:&nbsp;the&nbsp;last.<br>
downSampleRatio<br>
&nbsp;&nbsp;&nbsp;&nbsp;Downsampling&nbsp;factor&nbsp;that&nbsp;will&nbsp;be&nbsp;applied&nbsp;to&nbsp;the&nbsp;raw&nbsp;data.&nbsp;Multiple<br>
&nbsp;&nbsp;&nbsp;&nbsp;downsampling&nbsp;modes&nbsp;can&nbsp;be&nbsp;bitwise-ORed&nbsp;together,&nbsp;but&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;downSampleRatio&nbsp;must&nbsp;be&nbsp;the&nbsp;same&nbsp;for&nbsp;all&nbsp;modes.<br>
downSampleMode<br>
&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;of&nbsp;downsampling.<br>
data<br>
&nbsp;&nbsp;&nbsp;&nbsp;Numpy&nbsp;array&nbsp;to&nbsp;fill&nbsp;with&nbsp;the&nbsp;data.&nbsp;If&nbsp;None,&nbsp;create&nbsp;an&nbsp;empty&nbsp;one.<br>
&nbsp;<br>
Return<br>
------<br>
data&nbsp;:&nbsp;numpy&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;containing&nbsp;the&nbsp;raw&nbsp;data.<br>
numSamples&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;samples&nbsp;retrieved&nbsp;per&nbsp;waveform.<br>
overflow&nbsp;:&nbsp;numpy&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;containing&nbsp;whether&nbsp;the&nbsp;range&nbsp;was&nbsp;exceeded.</span></dd></dl>

<dl><dt><a name="PS3000-getDataV"><strong>getDataV</strong></a>(self, channel, numSamples=0, startIndex=0, downSampleRatio=1, downSampleMode=0, segmentIndex=0, returnOverflow=False, exceptOverflow=False, dataV=None, dataRaw=None, dtype=&lt;class 'numpy.float64'&gt;)</dt><dd><span class="code">Return&nbsp;the&nbsp;data&nbsp;of&nbsp;a&nbsp;single&nbsp;channel&nbsp;as&nbsp;an&nbsp;array&nbsp;of&nbsp;voltage&nbsp;values.<br>
&nbsp;<br>
Paramters<br>
---------<br>
channel<br>
&nbsp;&nbsp;&nbsp;&nbsp;Scope&nbsp;channel&nbsp;number&nbsp;or&nbsp;name.<br>
numSamples<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;samples&nbsp;to&nbsp;return.&nbsp;If&nbsp;0,&nbsp;take&nbsp;the&nbsp;calculated&nbsp;number&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;sampling&nbsp;interval/frequency.<br>
startIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;sample&nbsp;to&nbsp;start&nbsp;transfer.<br>
downSampleRatio<br>
&nbsp;&nbsp;&nbsp;&nbsp;Downsampling&nbsp;factor&nbsp;that&nbsp;will&nbsp;be&nbsp;applied&nbsp;to&nbsp;the&nbsp;raw&nbsp;data.&nbsp;Multiple<br>
&nbsp;&nbsp;&nbsp;&nbsp;downsampling&nbsp;modes&nbsp;can&nbsp;be&nbsp;bitwise-ORed&nbsp;together,&nbsp;but&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;downSampleRatio&nbsp;must&nbsp;be&nbsp;the&nbsp;same&nbsp;for&nbsp;all&nbsp;modes.<br>
downSampleMode<br>
&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;of&nbsp;downsampling.<br>
segmentIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;memory&nbsp;segment&nbsp;to&nbsp;get&nbsp;data&nbsp;from.<br>
returnOverflow<br>
&nbsp;&nbsp;&nbsp;&nbsp;Return&nbsp;whether&nbsp;the&nbsp;measurement&nbsp;exceeded&nbsp;the&nbsp;range,<br>
&nbsp;&nbsp;&nbsp;&nbsp;additionally&nbsp;to&nbsp;the&nbsp;data.<br>
exceptOverflow<br>
&nbsp;&nbsp;&nbsp;&nbsp;Raise&nbsp;an&nbsp;IOError&nbsp;exception&nbsp;on&nbsp;overflow.<br>
dataV<br>
&nbsp;&nbsp;&nbsp;&nbsp;Numpy&nbsp;array&nbsp;to&nbsp;fill&nbsp;with&nbsp;the&nbsp;data.&nbsp;If&nbsp;None,&nbsp;create&nbsp;an&nbsp;empty&nbsp;one.<br>
dtype<br>
&nbsp;&nbsp;&nbsp;&nbsp;Datatype&nbsp;for&nbsp;the&nbsp;numpy&nbsp;array&nbsp;to&nbsp;create.<br>
dataRaw<br>
&nbsp;&nbsp;&nbsp;&nbsp;Not&nbsp;used<br>
&nbsp;<br>
Return<br>
-----<br>
dataV&nbsp;:&nbsp;numpy&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Numpy&nbsp;array&nbsp;with&nbsp;the&nbsp;values&nbsp;in&nbsp;Volts.<br>
overflow&nbsp;:&nbsp;bool,&nbsp;only&nbsp;if&nbsp;returnOverflow&nbsp;is&nbsp;True<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;the&nbsp;measured&nbsp;value&nbsp;exceeded&nbsp;the&nbsp;measurement&nbsp;range.</span></dd></dl>

<dl><dt><a name="PS3000-getMaxMemorySegments"><strong>getMaxMemorySegments</strong></a>(self)</dt><dd><span class="code">Return&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;memory&nbsp;segments&nbsp;allowed&nbsp;by&nbsp;the&nbsp;device.</span></dd></dl>

<dl><dt><a name="PS3000-getMaxValue"><strong>getMaxValue</strong></a>(self)</dt><dd><span class="code">Return&nbsp;the&nbsp;maximum&nbsp;ADC&nbsp;value,&nbsp;used&nbsp;for&nbsp;scaling.</span></dd></dl>

<dl><dt><a name="PS3000-getMinValue"><strong>getMinValue</strong></a>(self)</dt><dd><span class="code">Return&nbsp;the&nbsp;minimum&nbsp;ADC&nbsp;value,&nbsp;used&nbsp;for&nbsp;scaling.</span></dd></dl>

<dl><dt><a name="PS3000-getResolution"><strong>getResolution</strong></a>(self)</dt><dd><span class="code">Get&nbsp;the&nbsp;currently&nbsp;set&nbsp;resolution.</span></dd></dl>

<dl><dt><a name="PS3000-getScaleAndOffset"><strong>getScaleAndOffset</strong></a>(self, channel)</dt><dd><span class="code">Return&nbsp;`channel`s&nbsp;scale&nbsp;and&nbsp;offset&nbsp;used&nbsp;to&nbsp;convert&nbsp;the&nbsp;raw&nbsp;waveform.<br>
&nbsp;<br>
To&nbsp;use:&nbsp;first&nbsp;multiply&nbsp;by&nbsp;the&nbsp;scale,&nbsp;then&nbsp;subtract&nbsp;the&nbsp;offset.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;dictionary&nbsp;with&nbsp;keys&nbsp;'scale'&nbsp;and&nbsp;'offset'.</span></dd></dl>

<dl><dt><a name="PS3000-getTriggerTimeOffset"><strong>getTriggerTimeOffset</strong></a>(self, segmentIndex=0)</dt><dd><span class="code">Get&nbsp;the&nbsp;trigger&nbsp;time&nbsp;offset&nbsp;in&nbsp;s&nbsp;for&nbsp;a&nbsp;waveform.<br>
&nbsp;<br>
Parameter<br>
---------<br>
segmentIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;memory&nbsp;segment&nbsp;in&nbsp;question.</span></dd></dl>

<dl><dt><a name="PS3000-getUnitInfo"><strong>getUnitInfo</strong></a>(self, info)</dt><dd><span class="code">Return&nbsp;a&nbsp;string&nbsp;containing&nbsp;information&nbsp;about&nbsp;`info`.</span></dd></dl>

<dl><dt><a name="PS3000-isReady"><strong>isReady</strong></a>(self)</dt><dd><span class="code">Return&nbsp;whether&nbsp;scope&nbsp;is&nbsp;ready&nbsp;to&nbsp;transfer&nbsp;data.</span></dd></dl>

<dl><dt><a name="PS3000-load_library"><strong>load_library</strong></a>(self, libname: str | None = None, dllPath: str | None = None)</dt><dd><span class="code">Load&nbsp;the&nbsp;library&nbsp;for&nbsp;the&nbsp;scope.<br>
&nbsp;<br>
:param:libname:&nbsp;Name&nbsp;of&nbsp;the&nbsp;library&nbsp;to&nbsp;load.&nbsp;If&nbsp;None,&nbsp;the&nbsp;default&nbsp;library&nbsp;for&nbsp;the&nbsp;oscilloscope&nbsp;will&nbsp;be&nbsp;loaded.<br>
:param:dllPath:&nbsp;Path&nbsp;to&nbsp;the&nbsp;dll.&nbsp;If&nbsp;None,&nbsp;the&nbsp;library&nbsp;will&nbsp;be&nbsp;searched&nbsp;for&nbsp;in&nbsp;the&nbsp;standard&nbsp;locations.&nbsp;Only&nbsp;used&nbsp;for&nbsp;Windows.</span></dd></dl>

<dl><dt><a name="PS3000-memorySegments"><strong>memorySegments</strong></a>(self, noSegments)</dt><dd><span class="code">Divide&nbsp;the&nbsp;scope&nbsp;memory&nbsp;into&nbsp;`noSegments`&nbsp;segments.<br>
&nbsp;<br>
The&nbsp;scope&nbsp;fills&nbsp;the&nbsp;available&nbsp;memory&nbsp;segment&nbsp;for&nbsp;a&nbsp;single&nbsp;capture.<br>
More&nbsp;segments&nbsp;allow&nbsp;several&nbsp;consecutive&nbsp;captures.<br>
The&nbsp;memory&nbsp;is&nbsp;distributed&nbsp;amongst&nbsp;the&nbsp;active&nbsp;channels:&nbsp;the&nbsp;number&nbsp;of<br>
samples&nbsp;available&nbsp;to&nbsp;each&nbsp;channel&nbsp;is&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;samples<br>
divided&nbsp;by&nbsp;2&nbsp;(for&nbsp;2&nbsp;channels)&nbsp;or&nbsp;4&nbsp;(for&nbsp;3&nbsp;or&nbsp;4&nbsp;channels)&nbsp;or<br>
8&nbsp;(for&nbsp;5&nbsp;to&nbsp;8&nbsp;channels).<br>
&nbsp;<br>
Returns<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;samples&nbsp;in&nbsp;the&nbsp;segment.</span></dd></dl>

<dl><dt><a name="PS3000-open"><strong>open</strong></a>(self, serialNumber=None)</dt><dd><span class="code">Open&nbsp;the&nbsp;scope,&nbsp;using&nbsp;`serialNumber`&nbsp;if&nbsp;given.</span></dd></dl>

<dl><dt><a name="PS3000-openUnitAsync"><strong>openUnitAsync</strong></a>(self, serialNumber=None)</dt><dd><span class="code">Open&nbsp;the&nbsp;scope&nbsp;asynchronously,&nbsp;using&nbsp;`serialNumber`&nbsp;if&nbsp;given.</span></dd></dl>

<dl><dt><a name="PS3000-openUnitProgress"><strong>openUnitProgress</strong></a>(self)</dt><dd><span class="code">Check&nbsp;the&nbsp;progress&nbsp;of&nbsp;the&nbsp;opening&nbsp;procedure.<br>
&nbsp;<br>
Return<br>
------<br>
progress<br>
&nbsp;&nbsp;&nbsp;&nbsp;Percentage&nbsp;of&nbsp;the&nbsp;opening&nbsp;procedure.<br>
completed&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;the&nbsp;opening&nbsp;has&nbsp;completed.</span></dd></dl>

<dl><dt><a name="PS3000-ping"><strong>ping</strong></a>(self)</dt><dd><span class="code">Ping&nbsp;unit&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;already&nbsp;opened&nbsp;device&nbsp;is&nbsp;connected.</span></dd></dl>

<dl><dt><a name="PS3000-rawToV"><strong>rawToV</strong></a>(self, channel, dataRaw, dataV=None, dtype=&lt;class 'numpy.float64'&gt;)</dt><dd><span class="code">Convert&nbsp;the&nbsp;raw&nbsp;data&nbsp;to&nbsp;voltage&nbsp;units.<br>
&nbsp;<br>
Parameters<br>
----------<br>
channel<br>
&nbsp;&nbsp;&nbsp;&nbsp;Scope&nbsp;channel&nbsp;number&nbsp;or&nbsp;name.<br>
dataRaw<br>
&nbsp;&nbsp;&nbsp;&nbsp;Raw&nbsp;data.<br>
dataV<br>
&nbsp;&nbsp;&nbsp;&nbsp;Numpy&nbsp;array&nbsp;to&nbsp;fill&nbsp;with&nbsp;the&nbsp;data.&nbsp;If&nbsp;None,&nbsp;create&nbsp;an&nbsp;empty&nbsp;one.<br>
dtype<br>
&nbsp;&nbsp;&nbsp;&nbsp;Datatype&nbsp;for&nbsp;the&nbsp;numpy&nbsp;array&nbsp;to&nbsp;create.<br>
&nbsp;<br>
Return<br>
------<br>
Numpy&nbsp;array&nbsp;with&nbsp;the&nbsp;measurement&nbsp;in&nbsp;V.</span></dd></dl>

<dl><dt><a name="PS3000-runBlock"><strong>runBlock</strong></a>(self, pretrig=0.0, segmentIndex=0, callback=None)</dt><dd><span class="code">Run&nbsp;a&nbsp;single&nbsp;block.<br>
&nbsp;<br>
Must&nbsp;have&nbsp;already&nbsp;called&nbsp;setSampling&nbsp;for&nbsp;proper&nbsp;setup.<br>
&nbsp;<br>
Parameters<br>
----------<br>
pretrig<br>
&nbsp;&nbsp;&nbsp;&nbsp;Fraction&nbsp;of&nbsp;samples&nbsp;before&nbsp;the&nbsp;trigger.<br>
segmentIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;scope&nbsp;memory&nbsp;segment&nbsp;to&nbsp;save&nbsp;data&nbsp;to.<br>
callback<br>
&nbsp;&nbsp;&nbsp;&nbsp;Function&nbsp;to&nbsp;call&nbsp;once&nbsp;the&nbsp;data&nbsp;acquisition&nbsp;finishes.</span></dd></dl>

<dl><dt><a name="PS3000-setAWGSimple"><strong>setAWGSimple</strong></a>(self, waveform, duration, offsetVoltage=None, pkToPk=None, indexMode='Single', shots=1, triggerType='Rising', triggerSource='ScopeTrig')</dt><dd><span class="code">Set&nbsp;the&nbsp;AWG&nbsp;to&nbsp;output&nbsp;your&nbsp;desired&nbsp;waveform.<br>
&nbsp;<br>
If&nbsp;you&nbsp;require&nbsp;precise&nbsp;control&nbsp;of&nbsp;the&nbsp;timestep&nbsp;increment,&nbsp;you&nbsp;should<br>
use&nbsp;setSigGenAritrarySimpleDeltaPhase&nbsp;instead<br>
&nbsp;<br>
Check&nbsp;setSigGenAritrarySimpleDeltaPhase&nbsp;for&nbsp;parameter&nbsp;explanation<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;actual&nbsp;duration&nbsp;of&nbsp;the&nbsp;waveform.</span></dd></dl>

<dl><dt><a name="PS3000-setAWGSimpleDeltaPhase"><strong>setAWGSimpleDeltaPhase</strong></a>(self, waveform, deltaPhase, offsetVoltage=None, pkToPk=None, indexMode='Single', shots=1, triggerType='Rising', triggerSource='ScopeTrig')</dt><dd><span class="code">Specify&nbsp;deltaPhase&nbsp;between&nbsp;each&nbsp;sample&nbsp;and&nbsp;not&nbsp;the&nbsp;total&nbsp;waveform<br>
duration.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;actual&nbsp;time&nbsp;duration&nbsp;of&nbsp;the&nbsp;waveform<br>
&nbsp;<br>
If&nbsp;pkToPk&nbsp;and&nbsp;offset&nbsp;Voltage&nbsp;are&nbsp;both&nbsp;set&nbsp;to&nbsp;None,&nbsp;then&nbsp;their&nbsp;values<br>
are&nbsp;computed&nbsp;as<br>
&nbsp;<br>
pkToPk&nbsp;=&nbsp;np.max(waveform)&nbsp;-&nbsp;np.min(waveform)<br>
offset&nbsp;=&nbsp;(np.max(waveform)&nbsp;+&nbsp;np.min(waveform))&nbsp;/&nbsp;2<br>
&nbsp;<br>
This&nbsp;should&nbsp;in&nbsp;theory&nbsp;minimize&nbsp;the&nbsp;quantization&nbsp;error&nbsp;in&nbsp;the&nbsp;ADC.<br>
&nbsp;<br>
else,&nbsp;the&nbsp;waveform&nbsp;should&nbsp;be&nbsp;a&nbsp;numpy&nbsp;int16&nbsp;type&nbsp;array&nbsp;with&nbsp;the<br>
containing&nbsp;waveform<br>
&nbsp;<br>
For&nbsp;the&nbsp;Quad&nbsp;mode,&nbsp;if&nbsp;offset&nbsp;voltage&nbsp;is&nbsp;not&nbsp;provided,&nbsp;then&nbsp;waveform[0]<br>
is&nbsp;assumed&nbsp;to&nbsp;be&nbsp;the&nbsp;offset.&nbsp;In&nbsp;quad&nbsp;mode,&nbsp;the&nbsp;offset&nbsp;voltage&nbsp;is&nbsp;the<br>
point&nbsp;of&nbsp;symmetry<br>
&nbsp;<br>
This&nbsp;is&nbsp;function&nbsp;provides&nbsp;a&nbsp;little&nbsp;more&nbsp;control&nbsp;than<br>
setAWGSimple&nbsp;in&nbsp;the&nbsp;sense&nbsp;that&nbsp;you&nbsp;are&nbsp;able&nbsp;to&nbsp;specify&nbsp;deltaPhase<br>
directly.&nbsp;It&nbsp;should&nbsp;only&nbsp;be&nbsp;used&nbsp;when&nbsp;deltaPhase&nbsp;becomes&nbsp;very&nbsp;large.<br>
&nbsp;<br>
Warning.&nbsp;Ideally,&nbsp;you&nbsp;would&nbsp;want&nbsp;this&nbsp;to&nbsp;be&nbsp;a&nbsp;power&nbsp;of&nbsp;2&nbsp;that&nbsp;way&nbsp;each<br>
sample&nbsp;is&nbsp;given&nbsp;out&nbsp;at&nbsp;exactly&nbsp;the&nbsp;same&nbsp;difference&nbsp;in&nbsp;time&nbsp;otherwise,<br>
if&nbsp;you&nbsp;give&nbsp;it&nbsp;something&nbsp;closer&nbsp;to&nbsp;.75&nbsp;you&nbsp;would&nbsp;obtain<br>
&nbsp;<br>
&nbsp;T&nbsp;&nbsp;|&nbsp;phase&nbsp;accumulator&nbsp;value&nbsp;|&nbsp;sample<br>
&nbsp;0&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;5&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
10&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
15&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
20&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>
25&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>
&nbsp;<br>
notice&nbsp;how&nbsp;sample&nbsp;0&nbsp;and&nbsp;3&nbsp;were&nbsp;played&nbsp;twice&nbsp;&nbsp;while&nbsp;others&nbsp;were&nbsp;only<br>
played&nbsp;once.<br>
This&nbsp;is&nbsp;why&nbsp;this&nbsp;low&nbsp;level&nbsp;function&nbsp;is&nbsp;exposed&nbsp;to&nbsp;the&nbsp;user&nbsp;so&nbsp;that&nbsp;he<br>
can&nbsp;control&nbsp;these&nbsp;edge&nbsp;cases<br>
&nbsp;<br>
I&nbsp;would&nbsp;suggest&nbsp;using&nbsp;something&nbsp;like&nbsp;this:&nbsp;if&nbsp;you&nbsp;care&nbsp;about&nbsp;obtaining<br>
evenly&nbsp;spaced&nbsp;samples&nbsp;at&nbsp;the&nbsp;expense&nbsp;of&nbsp;the&nbsp;precise&nbsp;duration&nbsp;of&nbsp;the<br>
your&nbsp;waveform<br>
To&nbsp;find&nbsp;the&nbsp;next&nbsp;highest&nbsp;power&nbsp;of&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;always&nbsp;a&nbsp;smaller&nbsp;sampling&nbsp;interval&nbsp;than&nbsp;the&nbsp;one&nbsp;you&nbsp;asked&nbsp;for<br>
math.pow(2,&nbsp;math.ceil(math.log(deltaPhase,&nbsp;2)))<br>
&nbsp;<br>
To&nbsp;find&nbsp;the&nbsp;next&nbsp;smaller&nbsp;power&nbsp;of&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;always&nbsp;a&nbsp;larger&nbsp;sampling&nbsp;interval&nbsp;than&nbsp;the&nbsp;one&nbsp;you&nbsp;asked&nbsp;for<br>
math.pow(2,&nbsp;math.floor(math.log(deltaPhase,&nbsp;2)))<br>
&nbsp;<br>
To&nbsp;find&nbsp;the&nbsp;nearest&nbsp;power&nbsp;of&nbsp;2<br>
math.pow(2,&nbsp;int(math.log(deltaPhase,&nbsp;2),&nbsp;+&nbsp;0.5))</span></dd></dl>

<dl><dt><a name="PS3000-setChannel"><strong>setChannel</strong></a>(self, channel='A', coupling='AC', VRange=2.0, VOffset=0.0, enabled=True, BWLimited=0, probeAttenuation=1.0)</dt><dd><span class="code">Set&nbsp;up&nbsp;a&nbsp;specific&nbsp;scope&nbsp;channel&nbsp;with&nbsp;the&nbsp;smallest&nbsp;range&nbsp;possible.<br>
&nbsp;<br>
Parameters<br>
-----------<br>
channel<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;channel&nbsp;to&nbsp;set&nbsp;up.<br>
coupling<br>
&nbsp;&nbsp;&nbsp;&nbsp;'AC'&nbsp;or&nbsp;'DC'.&nbsp;Note&nbsp;that&nbsp;if&nbsp;you&nbsp;set&nbsp;a&nbsp;channel&nbsp;to&nbsp;use&nbsp;AC&nbsp;coupling,<br>
&nbsp;&nbsp;&nbsp;&nbsp;you&nbsp;may&nbsp;need&nbsp;to&nbsp;make&nbsp;a&nbsp;"dummy&nbsp;call"&nbsp;to&nbsp;runBlock,&nbsp;or&nbsp;the&nbsp;first&nbsp;batch<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;data&nbsp;returned&nbsp;via&nbsp;getData*&nbsp;may&nbsp;be&nbsp;inaccurate.<br>
&nbsp;&nbsp;&nbsp;&nbsp;See&nbsp;<a href="https://www.picotech.com/support/topic35401.html">https://www.picotech.com/support/topic35401.html</a><br>
VRange<br>
&nbsp;&nbsp;&nbsp;&nbsp;Measurement&nbsp;range&nbsp;in&nbsp;V.<br>
VOffset<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An&nbsp;offset,&nbsp;in&nbsp;volts,&nbsp;to&nbsp;be&nbsp;added&nbsp;to&nbsp;the&nbsp;input&nbsp;signal&nbsp;before&nbsp;it<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reaches&nbsp;the&nbsp;input&nbsp;amplifier&nbsp;and&nbsp;digitizer.<br>
enabled<br>
&nbsp;&nbsp;&nbsp;&nbsp;Enable&nbsp;or&nbsp;disable&nbsp;the&nbsp;channel.<br>
BWLimited<br>
&nbsp;&nbsp;&nbsp;&nbsp;Limit&nbsp;the&nbsp;bandwidth.<br>
probeAttenuation<br>
&nbsp;&nbsp;&nbsp;&nbsp;See&nbsp;below.<br>
&nbsp;<br>
Return<br>
------<br>
Actual&nbsp;range&nbsp;of&nbsp;the&nbsp;scope&nbsp;as&nbsp;double.<br>
&nbsp;<br>
&nbsp;<br>
probeAttenuation<br>
----------------<br>
&nbsp;<br>
If&nbsp;using&nbsp;a&nbsp;probe&nbsp;(or&nbsp;a&nbsp;sense&nbsp;resitor),&nbsp;the&nbsp;`probeAttenuation`&nbsp;value&nbsp;is<br>
used&nbsp;to&nbsp;find&nbsp;the&nbsp;approriate&nbsp;channel&nbsp;range&nbsp;on&nbsp;the&nbsp;scope&nbsp;to&nbsp;use.<br>
&nbsp;<br>
e.g.&nbsp;to&nbsp;use&nbsp;a&nbsp;10x&nbsp;attenuation&nbsp;probe,&nbsp;you&nbsp;must&nbsp;supply&nbsp;the&nbsp;following<br>
parameters&nbsp;ps.<a href="#PS3000-setChannel">setChannel</a>('A',&nbsp;"DC",&nbsp;20.0,&nbsp;5.0,&nbsp;True,&nbsp;False,&nbsp;10.0)<br>
&nbsp;<br>
The&nbsp;scope&nbsp;will&nbsp;then&nbsp;be&nbsp;set&nbsp;to&nbsp;use&nbsp;the&nbsp;+-&nbsp;2V&nbsp;mode&nbsp;at&nbsp;the&nbsp;scope&nbsp;allowing<br>
you&nbsp;to&nbsp;measure&nbsp;your&nbsp;signal&nbsp;from&nbsp;-25V&nbsp;to&nbsp;+15V.<br>
After&nbsp;this&nbsp;point,&nbsp;you&nbsp;can&nbsp;set&nbsp;everything&nbsp;in&nbsp;terms&nbsp;of&nbsp;units&nbsp;as&nbsp;seen&nbsp;at<br>
the&nbsp;tip&nbsp;of&nbsp;the&nbsp;probe.&nbsp;For&nbsp;example,&nbsp;you&nbsp;can&nbsp;set&nbsp;a&nbsp;trigger&nbsp;of&nbsp;15V&nbsp;and&nbsp;it<br>
will&nbsp;trigger&nbsp;at&nbsp;the&nbsp;correct&nbsp;value.<br>
&nbsp;<br>
When&nbsp;using&nbsp;a&nbsp;sense&nbsp;resistor,&nbsp;lets&nbsp;say&nbsp;R&nbsp;=&nbsp;1.3&nbsp;ohm,&nbsp;you&nbsp;obtain&nbsp;the<br>
relation:<br>
V&nbsp;=&nbsp;IR,&nbsp;meaning&nbsp;that&nbsp;your&nbsp;probe&nbsp;as&nbsp;an&nbsp;attenuation&nbsp;of&nbsp;R&nbsp;compared&nbsp;to&nbsp;the<br>
current&nbsp;you&nbsp;are&nbsp;trying&nbsp;to&nbsp;measure.<br>
&nbsp;<br>
You&nbsp;should&nbsp;supply&nbsp;probeAttenuation&nbsp;=&nbsp;1.3<br>
The&nbsp;rest&nbsp;of&nbsp;your&nbsp;units&nbsp;should&nbsp;be&nbsp;specified&nbsp;in&nbsp;amps.<br>
&nbsp;<br>
Unfortunately,&nbsp;you&nbsp;still&nbsp;have&nbsp;to&nbsp;supply&nbsp;a&nbsp;`VRange`&nbsp;that&nbsp;is&nbsp;very&nbsp;close<br>
to&nbsp;the&nbsp;allowed&nbsp;values.&nbsp;This&nbsp;will&nbsp;change&nbsp;in&nbsp;furture&nbsp;version&nbsp;where&nbsp;we<br>
will&nbsp;find&nbsp;the&nbsp;next&nbsp;largest&nbsp;range&nbsp;to&nbsp;accomodate&nbsp;the&nbsp;desired&nbsp;range.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;to&nbsp;use&nbsp;units&nbsp;of&nbsp;mA,&nbsp;supply&nbsp;a&nbsp;probe&nbsp;attenuation&nbsp;of&nbsp;1.3E3.<br>
Note,&nbsp;the&nbsp;authors&nbsp;recommend&nbsp;sticking&nbsp;to&nbsp;SI&nbsp;units&nbsp;because&nbsp;it&nbsp;makes&nbsp;it<br>
easier&nbsp;to&nbsp;guess&nbsp;what&nbsp;units&nbsp;each&nbsp;parameter&nbsp;is&nbsp;in.</span></dd></dl>

<dl><dt><a name="PS3000-setExtTriggerRange"><strong>setExtTriggerRange</strong></a>(self, VRange=0.5)</dt><dd><span class="code">Set&nbsp;the&nbsp;range&nbsp;for&nbsp;the&nbsp;EXT&nbsp;trigger&nbsp;channel.<br>
&nbsp;<br>
This&nbsp;is&nbsp;only&nbsp;implemented&nbsp;for&nbsp;PS4000&nbsp;series&nbsp;devices&nbsp;where<br>
the&nbsp;only&nbsp;acceptable&nbsp;values&nbsp;for&nbsp;VRange&nbsp;are&nbsp;0.5&nbsp;or&nbsp;5.0.</span></dd></dl>

<dl><dt><a name="PS3000-setNoOfCaptures"><strong>setNoOfCaptures</strong></a>(self, noCaptures)</dt><dd><span class="code">Set&nbsp;the&nbsp;number&nbsp;of&nbsp;captures&nbsp;for&nbsp;one&nbsp;run&nbsp;of&nbsp;rapid&nbsp;block&nbsp;mode.<br>
&nbsp;<br>
If&nbsp;you&nbsp;do&nbsp;not&nbsp;call&nbsp;this&nbsp;function&nbsp;before&nbsp;a&nbsp;run,&nbsp;the&nbsp;driver&nbsp;will&nbsp;capture<br>
one&nbsp;waveform.</span></dd></dl>

<dl><dt><a name="PS3000-setResolution"><strong>setResolution</strong></a>(self, resolution)</dt><dd><span class="code">For&nbsp;6000-series,&nbsp;5000-series&nbsp;or&nbsp;certain&nbsp;4000-series&nbsp;scopes&nbsp;ONLY,<br>
sets&nbsp;the&nbsp;resolution.</span></dd></dl>

<dl><dt><a name="PS3000-setSamplingFrequency"><strong>setSamplingFrequency</strong></a>(self, sampleFrequency, noSamples, oversample=0, segmentIndex=0)</dt><dd><span class="code">Set&nbsp;the&nbsp;timebase&nbsp;according&nbsp;to&nbsp;a&nbsp;desired&nbsp;sampling&nbsp;frequency.<br>
&nbsp;<br>
Parameters<br>
----------<br>
sampleFrequency<br>
&nbsp;&nbsp;&nbsp;&nbsp;Desired&nbsp;sample&nbsp;frequency&nbsp;in&nbsp;samples&nbsp;per&nbsp;second.<br>
noSamples<br>
&nbsp;&nbsp;&nbsp;&nbsp;Desired&nbsp;number&nbsp;of&nbsp;samples.<br>
oversample<br>
&nbsp;&nbsp;&nbsp;&nbsp;Average&nbsp;over&nbsp;several&nbsp;measurements&nbsp;in&nbsp;the&nbsp;sample&nbsp;interval.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Not&nbsp;many&nbsp;picoscopes&nbsp;are&nbsp;capable&nbsp;of&nbsp;oversampling<br>
segmentIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;memory&nbsp;segment&nbsp;to&nbsp;store&nbsp;data&nbsp;into.<br>
&nbsp;<br>
Return<br>
------<br>
sampleRate&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;sample&nbsp;frequency&nbsp;in&nbsp;samples&nbsp;per&nbsp;second.<br>
maxSamples&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;samples&nbsp;possible&nbsp;in&nbsp;the&nbsp;memory&nbsp;segment.</span></dd></dl>

<dl><dt><a name="PS3000-setSamplingInterval"><strong>setSamplingInterval</strong></a>(self, sampleInterval, duration, oversample=0, segmentIndex=0)</dt><dd><span class="code">Set&nbsp;the&nbsp;timebase&nbsp;according&nbsp;to&nbsp;a&nbsp;desired&nbsp;sampling&nbsp;interval.<br>
&nbsp;<br>
Parameters<br>
----------<br>
sampleInterval<br>
&nbsp;&nbsp;&nbsp;&nbsp;Desired&nbsp;interval&nbsp;in&nbsp;seconds&nbsp;between&nbsp;two&nbsp;samples.<br>
duration<br>
&nbsp;&nbsp;&nbsp;&nbsp;Desired&nbsp;duration&nbsp;of&nbsp;measurement.<br>
oversample<br>
&nbsp;&nbsp;&nbsp;&nbsp;Average&nbsp;over&nbsp;several&nbsp;measurements&nbsp;in&nbsp;the&nbsp;sample&nbsp;interval.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Not&nbsp;many&nbsp;picoscopes&nbsp;are&nbsp;capable&nbsp;of&nbsp;oversampling.<br>
segmentIndex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;memory&nbsp;segment&nbsp;to&nbsp;store&nbsp;data&nbsp;into.<br>
&nbsp;<br>
Return<br>
------<br>
actualSampleInterval&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;sample&nbsp;interval&nbsp;in&nbsp;seconds&nbsp;according&nbsp;to&nbsp;the&nbsp;timebase.<br>
noSamples&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;samples&nbsp;in&nbsp;the&nbsp;measurement&nbsp;duration.<br>
maxSamples&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;samples&nbsp;possible&nbsp;in&nbsp;the&nbsp;memory&nbsp;segment.</span></dd></dl>

<dl><dt><a name="PS3000-setSigGenBuiltInSimple"><strong>setSigGenBuiltInSimple</strong></a>(self, offsetVoltage=0, pkToPk=2, waveType='Sine', frequency=1000000.0, shots=1, triggerType='Rising', triggerSource='None', stopFrequency=None, increment=10.0, dwellTime=0.001, sweepType='Up', numSweeps=0)</dt><dd><span class="code">Generate&nbsp;simple&nbsp;signals&nbsp;using&nbsp;the&nbsp;built-in&nbsp;waveforms.<br>
&nbsp;<br>
Parameters<br>
----------<br>
offsetVoltage<br>
&nbsp;&nbsp;&nbsp;&nbsp;Voltage&nbsp;offset.<br>
pkToPk<br>
&nbsp;&nbsp;&nbsp;&nbsp;Voltage&nbsp;from&nbsp;peak&nbsp;to&nbsp;peak<br>
waveType<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;of&nbsp;waveform:&nbsp;'Sine',&nbsp;'Square',&nbsp;'Triangle',&nbsp;'RampUp',<br>
&nbsp;&nbsp;&nbsp;&nbsp;'RampDown',&nbsp;and&nbsp;'DCVoltage'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Some&nbsp;hardware&nbsp;also&nbsp;supports&nbsp;these&nbsp;additional&nbsp;waveforms:<br>
&nbsp;&nbsp;&nbsp;&nbsp;'Sinc',&nbsp;'Gaussian',&nbsp;'HalfSine',&nbsp;and&nbsp;'WhiteNoise'.<br>
frequency<br>
&nbsp;&nbsp;&nbsp;&nbsp;Frequency&nbsp;in&nbsp;Hertz&nbsp;to&nbsp;start&nbsp;at.<br>
shots<br>
&nbsp;&nbsp;&nbsp;&nbsp;How&nbsp;often&nbsp;to&nbsp;repeat&nbsp;the&nbsp;waveform.&nbsp;If&nbsp;nonzero,&nbsp;`numSweeps`=0.<br>
triggerType<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;of&nbsp;trigger&nbsp;edge/threshold.&nbsp;See&nbsp;SIGGEN_TRIGGER_TYPES.<br>
triggerSource<br>
&nbsp;&nbsp;&nbsp;&nbsp;Source&nbsp;of&nbsp;the&nbsp;waveform&nbsp;trigger.&nbsp;See&nbsp;SIGGEN_TRIGGER_SOURCES.<br>
stopFrequency<br>
&nbsp;&nbsp;&nbsp;&nbsp;Frequency&nbsp;in&nbsp;Hertz&nbsp;to&nbsp;stop&nbsp;at.&nbsp;If&nbsp;None,&nbsp;do&nbsp;not&nbsp;sweep.<br>
increment<br>
&nbsp;&nbsp;&nbsp;&nbsp;Frequency&nbsp;change&nbsp;in&nbsp;Hertz,&nbsp;if&nbsp;in&nbsp;sweep&nbsp;mode.<br>
dwellTime<br>
&nbsp;&nbsp;&nbsp;&nbsp;Time&nbsp;in&nbsp;seconds&nbsp;between&nbsp;two&nbsp;frequency&nbsp;changes&nbsp;in&nbsp;sweep&nbsp;mode.<br>
sweepType<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;of&nbsp;sweeping&nbsp;the&nbsp;frequency:&nbsp;'Up',&nbsp;'Down',&nbsp;'UpDown',&nbsp;'DownUp'.<br>
numSweeps<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;sweeps.&nbsp;If&nbsp;nonzero,&nbsp;`shots`&nbsp;has&nbsp;to&nbsp;be&nbsp;zero.</span></dd></dl>

<dl><dt><a name="PS3000-setSimpleTrigger"><strong>setSimpleTrigger</strong></a>(self, trigSrc, threshold_V=0, direction='Rising', delay=0, timeout_ms=100, enabled=True)</dt><dd><span class="code">Set&nbsp;up&nbsp;a&nbsp;simple&nbsp;trigger.<br>
&nbsp;<br>
Parameters<br>
----------<br>
trigSrc<br>
&nbsp;&nbsp;&nbsp;&nbsp;Either&nbsp;a&nbsp;channel&nbsp;number&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;low&nbsp;level<br>
&nbsp;&nbsp;&nbsp;&nbsp;specifications&nbsp;of&nbsp;the&nbsp;scope&nbsp;or&nbsp;a&nbsp;string&nbsp;such&nbsp;as&nbsp;'A'&nbsp;or&nbsp;'AUX'.<br>
threshold_V<br>
&nbsp;&nbsp;&nbsp;&nbsp;Threshold&nbsp;at&nbsp;which&nbsp;to&nbsp;trigger&nbsp;in&nbsp;V.<br>
direction<br>
&nbsp;&nbsp;&nbsp;&nbsp;Can&nbsp;be&nbsp;a&nbsp;text&nbsp;string&nbsp;such&nbsp;as&nbsp;"Rising"&nbsp;or&nbsp;"Falling",<br>
&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;dict&nbsp;from&nbsp;self.<strong>THRESHOLD_TYPE</strong>[]&nbsp;corresponding<br>
&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;your&nbsp;trigger&nbsp;type.<br>
delay<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;clock&nbsp;cycles&nbsp;to&nbsp;wait&nbsp;from&nbsp;trigger&nbsp;conditions&nbsp;met<br>
&nbsp;&nbsp;&nbsp;&nbsp;until&nbsp;we&nbsp;actually&nbsp;trigger&nbsp;capture.<br>
timeout_ms<br>
&nbsp;&nbsp;&nbsp;&nbsp;Time&nbsp;to&nbsp;wait&nbsp;in&nbsp;ms&nbsp;from&nbsp;calling&nbsp;<a href="#PS3000-runBlock">runBlock</a>()&nbsp;or&nbsp;similar<br>
&nbsp;&nbsp;&nbsp;&nbsp;(e.g.&nbsp;when&nbsp;trigger&nbsp;arms)&nbsp;for&nbsp;the&nbsp;trigger&nbsp;to&nbsp;occur.&nbsp;If&nbsp;no&nbsp;trigger<br>
&nbsp;&nbsp;&nbsp;&nbsp;occurs&nbsp;it&nbsp;gives&nbsp;up&nbsp;&amp;&nbsp;auto-triggers.<br>
enabled<br>
&nbsp;&nbsp;&nbsp;&nbsp;Enable&nbsp;or&nbsp;disable&nbsp;the&nbsp;trigger.<br>
&nbsp;<br>
Notes<br>
-----<br>
-&nbsp;Support&nbsp;for&nbsp;offset&nbsp;is&nbsp;currently&nbsp;untested.<br>
-&nbsp;The&nbsp;AUX&nbsp;port&nbsp;(or&nbsp;EXT)&nbsp;only&nbsp;has&nbsp;a&nbsp;range&nbsp;of&nbsp;+-&nbsp;1V&nbsp;(at&nbsp;least&nbsp;in&nbsp;PS6000).</span></dd></dl>

<dl><dt><a name="PS3000-sigGenSoftwareControl"><strong>sigGenSoftwareControl</strong></a>(self, state=True)</dt><dd><span class="code">Trigger&nbsp;the&nbsp;AWG&nbsp;when&nbsp;configured&nbsp;with&nbsp;software&nbsp;triggering.</span></dd></dl>

<dl><dt><a name="PS3000-stop"><strong>stop</strong></a>(self)</dt><dd><span class="code">Stop&nbsp;scope&nbsp;acquisition.</span></dd></dl>

<dl><dt><a name="PS3000-waitReady"><strong>waitReady</strong></a>(self, spin_delay=0.01)</dt><dd><span class="code">Block&nbsp;until&nbsp;the&nbsp;scope&nbsp;is&nbsp;ready,&nbsp;retesting&nbsp;every&nbsp;`spin_delay`&nbsp;s.</span></dd></dl>

<hr>
Data descriptors inherited from <a href="picoscope.picobase.html#_PicoscopeBase">picoscope.picobase._PicoscopeBase</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><span class="code">dictionary&nbsp;for&nbsp;instance&nbsp;variables</span></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><span class="code">list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object</span></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="picoscope.picobase.html#_PicoscopeBase">picoscope.picobase._PicoscopeBase</a>:<br>
<dl><dt><strong>BW_LIMITS</strong> = None</dl>

<dl><dt><strong>ERROR_CODES</strong> = [[0, 'PICO_OK', 'The PicoScope XXXX is functioning correctly.'], [1, 'PICO_MAX_UNITS_OPENED', 'An attempt has been made to open more than PSXXXX_MAX_UNITS.'], [2, 'PICO_MEMORY_FAIL', 'Not enough memory could be allocated on the host machine.'], [3, 'PICO_NOT_FOUND', 'No PicoScope XXXX could be found.'], [4, 'PICO_FW_FAIL', 'Unable to download firmware.'], [5, 'PICO_OPEN_OPERATION_IN_PROGRESS'], [6, 'PICO_OPERATION_FAILED'], [7, 'PICO_NOT_RESPONDING', 'The PicoScope XXXX is not responding to commands from the PC.'], [8, 'PICO_CONFIG_FAIL', 'The configuration information in the PicoScope XXXX has become corrupt or is missing.'], [9, 'PICO_KERNEL_DRIVER_TOO_OLD', 'The picopp.sys file is too old to be used with the device driver.'], [10, 'PICO_EEPROM_CORRUPT', 'The EEPROM has become corrupt, so the device will use a default setting.'], [11, 'PICO_OS_NOT_SUPPORTED', 'The operating system on the PC is not supported by this driver.'], [12, 'PICO_INVALID_HANDLE', 'There is no device with the handle value passed.'], [13, 'PICO_INVALID_PARAMETER', 'A parameter value is not valid.'], [14, 'PICO_INVALID_TIMEBASE', 'The timebase is not supported or is invalid.'], [15, 'PICO_INVALID_VOLTAGE_RANGE', 'The voltage range is not supported or is invalid.'], [16, 'PICO_INVALID_CHANNEL', 'The channel number is not valid on this device or no channels have been set.'], [17, 'PICO_INVALID_TRIGGER_CHANNEL', 'The channel set for a trigger is not available on this device.'], [18, 'PICO_INVALID_CONDITION_CHANNEL', 'The channel set for a condition is not available on this device.'], [19, 'PICO_NO_SIGNAL_GENERATOR', 'The device does not have a signal generator.'], ...]</dl>

<dl><dt><strong>EXT_MAX_VALUE</strong> = None</dl>

<dl><dt><strong>EXT_MIN_VALUE</strong> = None</dl>

<dl><dt><strong>EXT_RANGE_VOLTS</strong> = None</dl>

</td></tr></table></td></tr></table><p>
<table class="section">
<tr class="decor functions-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><strong class="bigsection">Functions</strong></td></tr>
    
<tr><td class="decor functions-decor"><span class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td><td>&nbsp;</td>
<td class="singlecolumn"><dl><dt><a name="-POINTER"><strong>POINTER</strong></a>(...)</dt></dl>
 <dl><dt><a name="-byref"><strong>byref</strong></a>(...)</dt><dd><span class="code"><a href="#-byref">byref</a>(C&nbsp;instance[,&nbsp;offset=0])&nbsp;-&gt;&nbsp;byref-object<br>
Return&nbsp;a&nbsp;pointer&nbsp;lookalike&nbsp;to&nbsp;a&nbsp;C&nbsp;instance,&nbsp;only&nbsp;usable<br>
as&nbsp;function&nbsp;argument</span></dd></dl>
</td></tr></table>
</body></html>